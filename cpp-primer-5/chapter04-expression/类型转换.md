对于 `T* v = new E`, 这个 v 的 ''类型'' 看作有两种, T 是在编译时就决定的, 称作**静态类型**; E 是在运行时才决定的, 称作 **动态类型**.

动态对应着运行期间; 静态对应着编译期间.

从语法上来说 v 的真正类型只有 T, 也就是静态类型. 但是 E 往往才实际决定 v 的行为. 所以提出动态类型是有必要的.

将继承关系看作一棵树, 树根在最上面, 是总的基类.

1. upcast 向上转换: 子类转换为父类 (或者爷爷类或者曾爷爷类)
2. downcast 向下转换: 父类转换为子类 (或者孙子/曾孙子...)
3. sidecast 同辈转换: 转换成兄弟姐妹 (表兄弟姐妹...)

你可能会认为只有向上转换是允许的, 但其实不是.

举例:

```
Base* b = new Derived;
Derived d = (Base*) b;
```

上例子中 b 的静态类型是 Base (父类), 但是动态类型确实是 Derived (子类), 可以支持任何 Derived 的行为. 所以下面的强制转换是合法的.

继承树上的转换准则应该是: **任何对象的静态类型要派生动态类型**. 满足这样需求的转换就是可以发生的.

`dynamic_cast` 的转换检查转换是否可以发生, 如果不能发生, 则进行安全处理, 在不能转换的情况下:

1. 如果转换类型发生在指针中, 得到空指针. 这样即可通过检查空指针来检查转换是否合法.
2. 如果转换发生在引用中 -- 显然没有空引用这个类型, 所以这时转换会抛出一个 `std::bad_cast` 异常. 你可以通过检查异常来检查转换.

显然, 这个过程需要运行时检查类型, 即检查变量的动态类型, 这也是为什么这个转换叫做 dynamic.

`static_cast` 是 `dynamic_cast` 的兄弟版本, 只在编译期间进行转换操作. 这意味着, 只要目标类型和原始类型**有可能**发生合法的转换, `static_cast` 就是成功的. 怎样是没有可能的: 两种类型根本不在同一颗继承树中, 自然就不可能.

更进一步, `reinterpret_cast` 是更强悍的版本, 即使不在同一颗继承树上, 也可以发生.

`dynamic_cast` &rarr; `static_cast` &rarr; `reinterpret_cast` 安全性越来越差, 但自然的效率越来越高. 一到二减少了运行时的工作, 二到三减少了编译期间的工作.

当然, 如果使用了错误的转换, 并且依赖不安全的转换进行处理, 那么造成的结果由程序员负责.

---

继承树其实代表了一种等级的转换, 越向上等级越大. 静态类型的等级 (声称的权限) 需要大于等于实际类型的等级. 静态类型像一个容器, 决定往里放入的动态类型大小的上限.

语言中还有另一种依赖类型的权限转换, 即 `const` 类型. 当然这比较简单, 只有两层 (暂时认为只有两层).

从非 `const` 到 `const` 的转换是自然允许的, 就好比子类对象地址赋值给了父类指针. 但是相反的情况呢? 跟上面的类比, 其实也是可以的.

```
A& alpha = &ojbect;
const B& beta = alpha;
A& gamma = const_cast<A&>(beta);
```
